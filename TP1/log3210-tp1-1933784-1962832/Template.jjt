options {
 	JAVA_UNICODE_ESCAPE=true;
 	STATIC=false;					// 1 seul parseur actif a la fois (+ rapide)
 	MULTI=true;						// type noeud = f(nom noeud)
 	VISITOR=true;					// Cree une methode accept(visiteur)
 }

 //
 // PARSER DEFINITION
 //

 PARSER_BEGIN(Parser)

 package analyzer.ast;

 public class Parser
 {
 	public static ASTProgram ParseTree(java.io.InputStream input) throws ParseException
 	{
 		Parser c = new Parser(input);
 		return c.Program();
 	}
 }

 PARSER_END(Parser)

 //
 // LEXICAL ANALYSIS
 //

 // White space

 SKIP :
 {
 	< ( " " | "\t" | "\n" | "\r" )+	>
 }

 // Comments

 MORE :
 {
   "//" : IN_SINGLE_LINE_COMMENT
 |
   <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
 |
   "/*" : IN_MULTI_LINE_COMMENT
 }

 <IN_SINGLE_LINE_COMMENT>
 SPECIAL_TOKEN :
 {
   <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
 }

 <IN_FORMAL_COMMENT>
 SPECIAL_TOKEN :
 {
   <FORMAL_COMMENT: "*/" > : DEFAULT
 }

 <IN_MULTI_LINE_COMMENT>
 SPECIAL_TOKEN :
 {
   <MULTI_LINE_COMMENT: "*/" > : DEFAULT
 }

 <IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
 MORE :
 {
   < ~[] >
 }




 // Keywords
 TOKEN :
 {
 	< PRINT: "print" > |
 	< INPUT: "input" > |
    < FOR: "for" > |
    < WHILE: "while" > |
    < DO: "do"> |
 	< IF: "if" > |
 	< ELSE: "else" > |
 	< INT: "int" > |
 	< FLOAT: "float"> |
 	< BOOL: "bool" > |
 	< RETURN: "return" >

 	// À compléter au besoin
 }

 // Operators
 TOKEN :
 {
 	< ASSIGN: < EQUAL >  > |
 	< COMPARE: < LESS > | < LESSEQUAL > | < GREAT > | <GREATEQUAL > | < DIFF > | < EQUALEQUAL > > |
    < LOGIC: < AND > | < OR > > |
 	< #LESS: "<" > |
 	< #LESSEQUAL: "<=" > |
 	< #GREAT: ">" > |
 	< #GREATEQUAL: ">=" > |
 	< #DIFF: "!=" > |
 	< #EQUALEQUAL: "==" > |
 	< LAMBDA: <MINUS> <GREAT> > |

 	< PLUS: "+" > |
 	< MINUS: "-" > |
 	< FOIS: "*" > |
 	< DIV: "/" > |
    < NOT: "!" > |

 	< #EQUAL: "=" > |
 	< LPAREN: "(" > |
 	< RPAREN: ")" > |
 	< LACC: "{" > |
 	< RACC: "}" > |
 	< COLON: ":" > |
 	< SEMICOLON: ";" > |
 	< COMMA: "," > |
 	< #AND: "&&" > |
 	< #OR: "||" > |
 	< POWER: "^">
 	// À compléter au besoin
 }


 // Identifiers and numbers
 TOKEN :
 {
 	< IDENTIFIER: <LETTER> ( <LETTER> | <DIGIT> )* > |
 	< #LETTER: ["a"-"z","A"-"Z","_"] > |
 	< #DIGIT: ["0"-"9"] > |
 	< INTEGER: ["1"-"9"] (["0"-"9"])* | "0" > |
 	//TODO: Caution! Allows numbers such as "0000.23"... to fix!!!
 	< REAL: (<MINUS>)?((["1"-"9"] (<INTEGER>)*) | ("0") | "" )"." (["0"-"9"])* (<EXPONENT>)? |
     			  (<INTEGER>)+ <EXPONENT> > |
     < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
 }

 //
 // SYNTAX ANALYSIS
 //



 // à compléter
 void Stmt() #void: { }
 {
 	AssignStmt() <SEMICOLON> |
     WhileStmt() |
     DoWhileStmt() |
     IfStmt() |
     ForStmt() |
     LambdaStmt() <SEMICOLON> |
     ReturnStmt() <SEMICOLON>
 }

 ASTProgram Program() : { }
 {
 	Block() <EOF> { return jjtThis;  }
 }

 void Block()  #void: { }
 {
 	 (Stmt())*
 }

 // à finir -- commencez ici!

 void WhileStmt() : {}
 {
      <WHILE> ParanthesisExpr() FnctBody()
 }

 void DoWhileStmt() : {}
 {
     <DO> FnctBody() <WHILE> ParanthesisExpr() <SEMICOLON>
 }

 void ForStmt(): {}
 {
     <FOR> <LPAREN> (AssignStmt())? <SEMICOLON> (Expr())? <SEMICOLON> (AssignStmt())? <RPAREN> FnctBody()
 }

 void LambdaStmt(): {}
 {
     <LPAREN> ((<INT> | <BOOL> | <FLOAT>) Identifier() (<COMMA>)?)* <RPAREN> <LAMBDA> FnctBody()
 }

 void IfStmt(): {}
 {
    <IF> ParanthesisExpr() FnctBody() (<ELSE> ( LOOKAHEAD(2) FnctBody()#elseExpr(>1) | IfStmt()#elseif) | {})
 }

 void ParanthesisExpr() #void: {}
 {
     (<LPAREN> Expr() <RPAREN>)#ParanthesisExpr(>1)
 }

 void FnctBody() #void: {}
 {
     <LACC> Block() <RACC>
     |
     Stmt()
 }

 void ReturnStmt(): {}
 {
     <RETURN> Expr()
 }

 void AssignStmt() #void: { }
 {
     (Identifier() <ASSIGN> (LOOKAHEAD(2) Expr() | LambdaStmt()))#AssignStmt(>1)
 }

 void Expr() #void: {}
 {
     IntLogicExpr()
 }
void IntLogicExpr() #void: { }
{
    ComparisionExpr() (LOOKAHEAD(2)
         <LOGIC> ComparisionExpr()
    )*
}

 void ComparisionExpr() #void: { }
 {
    (AddExpr() (LOOKAHEAD(2)
       <COMPARE> AddExpr()
    )*) #CompareExpr(>1)
 }

 void AddExpr() #void: { }
 {
     (MulExpr() (
         (<PLUS> | <MINUS>) MulExpr() #Addition(>1)
     )*)#AddMin(>1)
 }

 void MulExpr()  #void: { }
 {
     (PowExpr() (
         (<FOIS> | <DIV>) PowExpr() #MultExpr(>1)
     )*)#MulDiv(>1)
 }

 void PowExpr() #void : {}
 {
 	(NegExpr() ( <POWER> NegExpr() )*)#Powred(>1)
 }

 void NegExpr() #void: {}
 {
 	((("-")+ NotExpr())
 	|
 	NotExpr())#NegExpr(>1)
 }

 void NotExpr() #void: {}
 {
    (<NOT>)* BasicExpr()#NotExpr(>1)
 }

 void BasicExpr() #void: {}
 {
 	LOOKAHEAD(2) FctExpr() |
 	Identifier()|
 	IntValue() |
 	RealValue() |
 	ParanthesisExpr()
 }

 void FctExpr(): { }
 {
 	<IDENTIFIER> "(" Expr() [ "," Expr() ] ")"
 }

 void Identifier() : { }
 {
 	<IDENTIFIER>
 }

 void IntValue() : { }
 {
 	<INTEGER>
 }

 void RealValue() : { }
 {
     <REAL>
 }